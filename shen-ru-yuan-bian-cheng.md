# 深入元编程

方法合成是元编程最为强大的一种形式。你可以基于运行时上下文和对象的状态，改变API以及对象的行为。你可以抛开原作者的意图，将已存在的类按照自己的需求进行修改。

方法合成直到最近才在JS中得到支持。在此之前你能做的仅仅只是方法注入。随着方法合成和两个新的类`Reflect`和`Proxy`的介绍，你可以在方法调用执行期间进行劫持，并且按照你希望的方式改变调用的命运。

由于拥有了运行时合成成员的能力，一个类的不同对象可能包含不同的方法和行为。尽管这是一个高度复杂的编程方式，它也为更改对象行为提供了现象级的弹性，同时让代码产生难以置信的扩展性。

`Reflect`类是查询和获取属性，方法，以及对象元数据的一个门户接口。无论何时你想获取对象元数据的一些详情，例如，获取对象的原型，`Reflect`可以帮助你实现这样的操作。

`Proxy`是元编程的忍者。它可以封装对象，并且像一个拦截器一样存在。你可以配置一个proxy，在运行时动态的将一个调用分发到被封装对象真实方法，或是分发到一个你选择的替代方法。用这样的方式，你可以有选择性的更改已知类的行为，而不会改变它们的源码。

尽管`Proxy`是一个合成你的自定义行为的途径，目前最好合成预定义行为的方案是装饰器(decorator)。换而言之，若要伪造自定义的动态方法，使用`Proxy`。若想注入第三方创建的方法，使用装饰器。尽管装饰器目前还未被JS原生支持，我们可以用转译工具来提前使用它。

## Reflect的目的

`Reflect`有两个主要的目的：

- 它是对象上进行的各种元操作的首要场所。例如`Reflect`提供方法来获取和设置对象的原型，并且检查对象上是否存在某个属性，等等。

- `Proxy`类默认将它的方法发送到`Reflect`。之后，当使用一个proxy时，我们只可以覆盖选中的操作，并且方便的将剩余部分留给默认实现。

`Reflect`中有两大类方法，我们选取其中一些感兴趣的，并且经常使用的部分进行学习。